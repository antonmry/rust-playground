use std::sync::Arc;

use anyhow::{anyhow, bail, Context, Result};
use async_trait::async_trait;
use datafusion::arrow::datatypes::{DataType, Field, Schema, SchemaRef};
use datafusion::arrow::record_batch::RecordBatch;
use datafusion::catalog::{Session, TableFunctionImpl, TableProvider};
use datafusion::common::{DataFusionError, Result as DataFusionResult, ScalarValue};
use datafusion::datasource::MemTable;
use datafusion::datasource::TableType;
use datafusion::logical_expr::Expr;
use datafusion::physical_plan::ExecutionPlan;
use datafusion::prelude::SessionContext;
use datafusion::sql::parser::{DFParser, Statement};

use crate::acp_client::{run_acp, AcpConfig};
use crate::sql_executor::SqlExecutor;

pub struct ClaudeParser<'a> {
    sql: &'a str,
}

pub enum ClaudeStatement {
    DFStatement(Box<Statement>),
    Claude(String),
}

impl<'a> ClaudeParser<'a> {
    pub fn new(sql: &'a str) -> Result<Self> {
        Ok(Self { sql })
    }

    pub fn parse_statement(&mut self) -> Result<ClaudeStatement> {
        let trimmed = self.sql.trim();
        let first_word_end = trimmed
            .find(|c: char| c.is_whitespace())
            .unwrap_or(trimmed.len());
        let first_word = &trimmed[..first_word_end];
        if first_word.eq_ignore_ascii_case("CLAUDE") {
            let query = trimmed[first_word_end..].trim();
            if query.is_empty() {
                bail!("CLAUDE statement requires a natural language query")
            }
            return Ok(ClaudeStatement::Claude(query.to_string()));
        }

        let mut statements = DFParser::parse_sql(self.sql)?;
        if statements.is_empty() {
            bail!("No SQL statement found")
        }

        let stmt = statements
            .pop_front()
            .ok_or_else(|| anyhow!("No SQL statement found"))?;
        Ok(ClaudeStatement::DFStatement(Box::new(stmt)))
    }
}

pub fn register_claude_table_function(
    ctx: &SessionContext,
    executor: Arc<SqlExecutor>,
    config: Arc<AcpConfig>,
) -> Result<()> {
    let function = ClaudeTableFunction { executor, config };
    ctx.register_udtf("claude", Arc::new(function));
    Ok(())
}

struct ClaudeTableFunction {
    executor: Arc<SqlExecutor>,
    config: Arc<AcpConfig>,
}

impl std::fmt::Debug for ClaudeTableFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ClaudeTableFunction")
            .finish_non_exhaustive()
    }
}

impl TableFunctionImpl for ClaudeTableFunction {
    fn call(&self, args: &[Expr]) -> DataFusionResult<Arc<dyn TableProvider>> {
        if args.len() != 1 {
            return Err(DataFusionError::Plan(
                "claude() expects exactly 1 argument".to_string(),
            ));
        }

        let query = match &args[0] {
            Expr::Literal(ScalarValue::Utf8(Some(query)), _)
            | Expr::Literal(ScalarValue::LargeUtf8(Some(query)), _) => query.clone(),
            _ => {
                return Err(DataFusionError::Plan(
                    "claude() argument must be a string literal".to_string(),
                ))
            }
        };

        let executor = self.executor.clone();
        let config = self.config.clone();
        match materialize_claude_query(query, executor, config) {
            Ok((schema, batches)) => Ok(Arc::new(ClaudeMaterializedTableProvider {
                schema,
                batches,
            })),
            Err(e) => {
                let schema = Arc::new(Schema::new(vec![Field::new(
                    "result",
                    DataType::Utf8,
                    true,
                )]));
                Ok(Arc::new(ClaudeErrorTableProvider {
                    schema,
                    error: e.to_string(),
                }))
            }
        }
    }
}

fn materialize_claude_query(
    query: String,
    executor: Arc<SqlExecutor>,
    config: Arc<AcpConfig>,
) -> Result<(SchemaRef, Vec<RecordBatch>)> {
    let join_result = std::thread::spawn(move || -> Result<(SchemaRef, Vec<RecordBatch>)> {
        let rt = tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .context("Failed to build Tokio runtime for claude() table function")?;
        rt.block_on(async move {
            let acp_result = run_acp(&query, executor.clone(), &config)
                .await
                .context("ACP query generation failed")?;
            let df = executor
                .execute_sql(&acp_result.sql)
                .await
                .with_context(|| {
                    format!(
                        "Failed to execute SQL generated by claude(): {}",
                        acp_result.sql
                    )
                })?;
            let schema = Arc::new(df.schema().as_arrow().clone());
            let batches = df
                .collect()
                .await
                .context("Failed collecting SQL results")?;
            Ok((schema, batches))
        })
    })
    .join();

    match join_result {
        Ok(result) => result,
        Err(_) => bail!("claude() worker thread panicked"),
    }
}

#[derive(Debug)]
struct ClaudeMaterializedTableProvider {
    schema: SchemaRef,
    batches: Vec<RecordBatch>,
}

#[async_trait]
impl TableProvider for ClaudeMaterializedTableProvider {
    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn schema(&self) -> SchemaRef {
        Arc::clone(&self.schema)
    }

    fn table_type(&self) -> TableType {
        TableType::Base
    }

    async fn scan(
        &self,
        state: &dyn Session,
        projection: Option<&Vec<usize>>,
        filters: &[Expr],
        limit: Option<usize>,
    ) -> DataFusionResult<Arc<dyn ExecutionPlan>> {
        let memtable = MemTable::try_new(self.schema.clone(), vec![self.batches.clone()])?;
        memtable.scan(state, projection, filters, limit).await
    }
}

#[derive(Debug)]
struct ClaudeErrorTableProvider {
    schema: SchemaRef,
    error: String,
}

#[async_trait]
impl TableProvider for ClaudeErrorTableProvider {
    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn schema(&self) -> SchemaRef {
        Arc::clone(&self.schema)
    }

    fn table_type(&self) -> TableType {
        TableType::Base
    }

    async fn scan(
        &self,
        _state: &dyn Session,
        _projection: Option<&Vec<usize>>,
        _filters: &[Expr],
        _limit: Option<usize>,
    ) -> DataFusionResult<Arc<dyn ExecutionPlan>> {
        Err(DataFusionError::Execution(self.error.clone()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_claude_parser_recognises_claude() {
        let mut parser = ClaudeParser::new("CLAUDE show me all tables").unwrap();
        match parser.parse_statement().unwrap() {
            ClaudeStatement::Claude(query) => assert_eq!(query, "show me all tables"),
            _ => panic!("Expected ClaudeStatement::Claude"),
        }
    }

    #[test]
    fn test_claude_parser_case_insensitive() {
        for prefix in &["CLAUDE", "claude", "Claude", "cLaUdE"] {
            let input = format!("{prefix} do something");
            let mut parser = ClaudeParser::new(&input).unwrap();
            match parser.parse_statement().unwrap() {
                ClaudeStatement::Claude(query) => assert_eq!(query, "do something"),
                _ => panic!("Expected Claude statement for prefix '{prefix}'"),
            }
        }
    }

    #[test]
    fn test_claude_parser_delegates_sql() {
        let mut parser = ClaudeParser::new("SELECT 1").unwrap();
        match parser.parse_statement().unwrap() {
            ClaudeStatement::DFStatement(_) => {}
            ClaudeStatement::Claude(_) => panic!("Should not be a Claude statement"),
        }
    }

    #[test]
    fn test_claude_parser_edge_cases() {
        // Empty query after CLAUDE keyword — should error
        let mut parser = ClaudeParser::new("CLAUDE").unwrap();
        assert!(parser.parse_statement().is_err());

        // Whitespace-only after CLAUDE — should error
        let mut parser = ClaudeParser::new("CLAUDE   ").unwrap();
        assert!(parser.parse_statement().is_err());

        // CLAUDE inside a string literal (should NOT be intercepted)
        let mut parser = ClaudeParser::new("SELECT 'CLAUDE is great'").unwrap();
        match parser.parse_statement().unwrap() {
            ClaudeStatement::DFStatement(_) => {}
            ClaudeStatement::Claude(_) => panic!("Should not intercept CLAUDE inside string"),
        }
    }

    #[tokio::test]
    async fn test_claude_table_function_registers_for_planning() {
        let executor = Arc::new(SqlExecutor::new().await.unwrap());
        let config = Arc::new(AcpConfig::default());
        register_claude_table_function(&executor.ctx, executor.clone(), config).unwrap();

        let df = executor.ctx.sql("SELECT * FROM claude('test')").await;
        assert!(df.is_ok());
    }
}
